'use strict';

var config      = require('config');
var execFile    = require('child_process').execFile;
var errors      = require('../lang/fr/errors');
var formatting  = require('../helpers/formatting');
var random      = require('../helpers/random');
var requestify  = require('requestify');
var models      = require('../models').sequelize.models;
var Service     = models.Service;
var Transaction = models.Transaction;

/**
 * Instanciate a new transaction.
 *
 * The "amount" GET parametter have to be numeric.
 *
 * @param {Object}   req
 * @param {Object}   res
 * @param {Function} next
 */
exports.new = function(req, res, next) {
    // The amount have to be between minAmount and maxAmount values choosen for the
    // current service. This prevents the user to buy too much things at once
    // (account stolen, etc.) or to avoid amounts under the bank's fee.
    if (res.locals.service.minAmount > req.params.amount || res.locals.service.maxAmount < req.params.amount) {
        req.app.locals.logger.warn('Invalid amount via ' + res.locals.service.name + ': should be between '
                                  + res.locals.service.minAmount + ' and ' + res.locals.service.maxAmount
                                  + ' but requested amount is ' + req.params.amount + '€.');
        res.status(400);
        return next(new Error('Montant invalide.'));
    }

    // Create the transaction and ensure the id and token are unique.
    // TODO: Refactoring :')
    var id;
    new Promise(function(resolve) {
        random.generateUnique(Transaction, 'id', 15)(resolve);
    }).then(function(id_) {
        id = id_;
        return new Promise(function(resolve) {
            random.generateUnique(Transaction, 'token', 25)(resolve);
        });
    }).then(function(token) {
        Transaction.create({
            id: id,
            token: token,
            amount: req.params.amount,
            data: req.body.data
        })
        .then(function(transaction) {
            // Log any new transaction...
            req.app.locals.logger.info('New transaction #' + transaction.id + ' via ' + res.locals.service.name + ' for ' + formatting.toMonetary(req.params.amount) + ' €.');
            return res.json({ id: transaction.id, token: transaction.token }).end();
        })
        .catch(function(err) {
            //... or any failing transaction.
            req.app.locals.logger.error('Error while creating the transaction via ' + res.locals.service.name + ': ' + err);
            return next(err);
        });
    });
}

/**
 * Show the payment form, generated by Sherlock's "request" binary.
 *
 * Since the form expires, it should not be cached.
 *
 * @param {Object}   req
 * @param {Object}   res
 * @param {Function} next
 */
exports.initiate = function(req, res, next) {

    Transaction.find({ where: { id: req.params.id } })
    .then(function(transaction) {

        if ( ! transaction) {
            req.app.locals.logger.warn('Transaction not found: ' + req.params.id);
            res.status(404);
            return next(new Error('La transaction n\'a pas été trouvée !'));
        }

        // Prepare the command to be executed.
        var command = config.get('sherlocks').request;

        var params = [
            'pathfile=' + config.get('sherlocks').pathfile,
            'merchant_id=' + config.get('sherlocks').merchant_id,
            'amount=' + formatting.fromMonetary(transaction.amount),
            'data=' + transaction.id
        ];

        // All the params are escaped by execFile by passing it in second argument ;-)
        execFile(command, params, function(error, stdout, stderr) {
            // Check for the presence of the sherlocks binary.
            if (error && error.code === 'ENOENT') {
                req.app.locals.logger.error('Unable to execute the sherlocks binary.');
                return next(new Error('Impossible d\'exécuter Sherlocks\'s !'));
            }
            // Handle sherlocks errors. The return value is given between the
            // two firsts "!". -1 indicates an unrecoverable error.
            if (stdout.indexOf('!-1!') === 0) {
                req.app.locals.logger.error('Sherlock\'s error: ' + error + ' - stdout: ' + stdout + ' - stderr: ' + stderr);
                res.status(500);
                return next(new Error('Erreur interne de Sherlock\'s !'));
            }

            // Response format: !0!!<FORM METHOD=POST ACTION="(.....)>!
            transaction.form = stdout.split('!')[3];
            transaction.save();

            return res.render('initiate', { transaction: transaction });
        });
    });
}

/**
 * User transaction status.
 *
 * @param {Object} req
 * @param {Object} res
 */
exports.status = function(req, res) {
    // The route have to be called from via AJAX, from the loading page.
    if (req.xhr) {
        Transaction.find({ where: { token: req.params.token }, include: [{ model: Service, as: 'Service' }] })
        .then(function(transaction) {
            if ( ! transaction) {
                return res.status(404).json({ status: 'error', message: 'Transaction introuvable.' }).end();
            }

            if ( ! transaction.confirmed) {
                return res.json({ status: 'error', message: 'Transaction non-confirmée.' }).end();
            }


            var url = 'http://' + transaction.Service.host + '/' + transaction.Service.successUrl;

            requestify.post(url, {
                amount: transaction.amount,
                data: transaction.data,
                token: transaction.token
            })
            .then(function(response) {
                // Redirect the user to the right URL.
                var body = response.getBody();
                return res.json({ status: 'success', data: { 'url': body.url } }).end();
            })
            .catch(function() {
                req.app.locals.logger('Unable to do the request to the service.');
                return res.status(500).json({ status: 'error', message: 'Impossible de contacter le service.' }).end();
            });

        });
    } else {
        return res.status(400).json({ status: 'error', message: 'ಠ_ಠ' }).end();
    }
}
